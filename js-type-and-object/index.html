<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Allenmind">
  <!-- Open Graph Data -->
  <meta property="og:title" content="Javascript数据类型总结和对象的分类"/>
  <meta property="og:description" content="这是Allenmind的个人博客" />
  <meta property="og:site_name" content="Allenmind&#39;s Blog"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="https://allenmind.cn"/>
  
    <link rel="alternate" href="/atom.xml" title="Allenmind&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.jpg">
  

  <!-- Site Title -->
  <title>Allenmind's Blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/mountain.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Javascript数据类型总结和对象的分类</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  首页
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  归档
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/AllenMinD">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="/categories">
                  
                  分类
                  
                </a>
              </li>
            
              <li>
                <a href="/tags">
                  
                  标签
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>


<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Allenmind</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-04-07</span>
            <span class="time">16:48:45</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/Javascript/">Javascript</a>
</span>
          
          <!-- 阅读统计 -->
          <span class="read-count info">
            <span id="busuanzi_container_page_pv">
              阅读量 <span id="busuanzi_value_page_pv"></span> 次
            </span>            
          </span>
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/数据类型/">#数据类型</a> <a class="tag" href="/tags/对象/">#对象</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>这是一篇关于Javascript数据类型总结和对象的分类的文章。在书写这篇文章的过程中，再次验证了一个道理：在寻找答案的过程中，你会找到比答案本身还要多的知识。一开始本来只想总结红宝书中的Js的数据类型章节的内容，但是觉得引用类型部分说得还不够明确，后来再去看了《了不起的Js》、ECMAScript规范和犀牛书，从“数据类型”，“引用类型”、再慢慢牵扯出“对象的分类”和对构造函数的重新思考，不得不说，这一过程实在是太刺激了。<br><a id="more"></a></p>
<h1>Javascript数据类型总结和对象的分类</h1>

<p><strong>目录</strong></p>
<ol>
<li><a href="#chapter1">Js数据类型</a></li>
<li><a href="#chapter2">基本类型和引用类型的区别</a></li>
<li><a href="#chapter3">基本类型中，要注意的几点</a></li>
<li><a href="#chapter4">关于对象</a></li>
</ol>
<p><strong>参考文献</strong></p>
<p><a href="http://www.ecma-international.org/ecma-262/5.1/" target="_blank" rel="external">ECMAScript-262</a><br><a href="http://www.ituring.com.cn/book/tupubarticle/10978" target="_blank" rel="external">《了不起的Js 中卷》第一章</a><br>《Javascript高级程序设计》第三章、第四章、第五章<br>《Javascript权威指南》第六章</p>
<h2 id="chapter1">一、Js数据类型</h2>

<p>在《了不起的Js 中卷》第一章中，有一句话深受启发：</p>
<blockquote>
<p>JavaScript 中的变量是没有类型的，只有【值】才有。变量可以随时持有任何类型的值。在对变量执行 typeof 操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型，因为 JavaScript 中的变量没有类型。</p>
</blockquote>
<p>（typeof 运算符总是会返回一个字符串：<code>typeof typeof 42; // &quot;string&quot;</code>）</p>
<p>ECMAScript有6种数据（值）类型：</p>
<ul>
<li>Undefined类型 // undefined  </li>
<li>Null类型 // null</li>
<li>Boolean类型 // true、false   </li>
<li>Number类型 // 1、2、3…   </li>
<li>String类型 // “a”、”B”、”123”  </li>
<li>Object类型 // {a: 1, fun: function(){console.log(this.a)}}</li>
</ul>
<p>其中，Undefined、Null、Boolean、Number、String类型的数据（值）被称为primitive value（直译为：原始数值）。Undefined、Null、Boolean、Number、String类型属于“基本类型”。</p>
<p>Object类型的数据（值）（即：对象的实例，形如<code>{...}</code>），实际上是一些属性的集合，每个Object类型的数据（值）都有一个prototype object（原型对象）。Object类型的值存放在堆中。Object类型属于“引用类型”。</p>
<p>这里有一个问题：什么是“基本类型”、“引用类型”呢？</p>
<blockquote>
<p>如果一个数据（值）在赋值给一个变量时，是把【值的本身】直接赋给了变量的话，那么这个值属于基本类型。</p>
<p>如果一个数据（值）在赋值给一个变量时，只是把这个【值的引用（或者说指针）】赋给了变量的话，那么这个值属于引用类型。</p>
</blockquote>
<p>Object类型之所以属于引用类型，是因为Object类型的值在赋值给一个变量时，只是把该值的引用（指针）赋给了变量，如果想要把该值本身赋给变量，就要使用我们平常常说的“浅拷贝”、“深拷贝”（通过递归的方式，把值中的每一个属性都“拷贝”出一个“副本”，把这些属性的“副本”组合成一个新的值，再把这个值赋给变量）。</p>
<p>现在我们知道<strong>对象的实例其实就是一个Object类型的值</strong>，而且我们还知道Array对象、Function对象、RegExp对象、Date对象Boolean对象、String对象和Number对象等都是<strong>继承</strong>Object对象的，所以平常所说的Array类型、Function类型、RegExp类型等其实均可看作是Object类型的“子类型”，所以Array类型、Function类型、RegExp类型、Date类型等都属于引用类型。</p>
<p><img src="/js-type-and-object/pic5.png" alt="pic"></p>
<h2 id="chapter2">二、基本类型和引用类型的区别</h2>

<p>我们现在知道了，Javascript中的数据类型主要有6种，并分为两类：基本类型、引用类型。</p>
<p>定义基本类型值和引用类型值的方式是类似的：创建一个变量，并为该变量赋值。</p>
<p>而基本类型和引用类型的区别主要有2个：</p>
<ol>
<li><p><strong>值被保存到变量后的操作方式</strong><br>对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。<br>而基本类型的值，不可以为其添加属性和方法。</p>
</li>
<li><p><strong>复制变量中的值时的方式</strong><br> 在把一个变量中的值，复制到另一个变量中时（a = b），基本类型和引用类型的处理方式并不相同。</p>
<p> 如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。  </p>
<p> 例如：<br> var num1 = 5;<br> var num2 = num1;  </p>
<p> 在此，num1 中保存的值是5。当使用num1 的值来初始化num2 时，num2 中也保存了值5。但num2中的5 与num1 中的5 是完全独立的，该值只是num1 中5 的一个副本。此后，这两个变量可以参与任何操作而不会相互影响。下图形象地展示了复制基本类型值的过程。  </p>
<p> <img src="/js-type-and-object/pic1.PNG" alt="pic">  </p>
<p> 当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个【指针】，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。  </p>
<p> 例如：  </p>
<p> var obj1 = new Object();<br> var obj2 = obj1;<br> obj1.name = “Nicholas”;<br> alert(obj2.name); //“Nicholas”  </p>
<p> 首先，变量obj1 保存了一个对象的新实例。然后，这个值被复制到了obj2 中；换句话说，obj1和obj2 都指向同一个对象。这样，当为obj1 添加name 属性后，可以通过obj2 来访问这个属性，因为这两个变量引用的都是同一个对象。下图展示了保存在变量对象中的变量和保存在堆中的对象之间的这种关系。  </p>
<p> <img src="/js-type-and-object/pic2.PNG" alt="pic"></p>
</li>
</ol>
<h2 id="chapter3">三、基本类型中，要注意的几点</h2>

<ol>
<li><p><strong>【Undefined类型和Null类型的区分】</strong>  </p>
<ul>
<li><p>Undefined类型的值只有一个，即undefined。当一个变量被声明（var）后，但未被给定初值时，变量的值默认为undefined。（注意：如果变量未被声明（var），它只有一种操作是合法的，就是typeof，此时会返回”undefined”类型，此外所有操作都是不合法的，会报错referrence erro…）  </p>
</li>
<li><p>Null类型的值也是只有一个，即null，这个值表示空对象指针，所以用typeof来检测时，会返回“object”。  </p>
</li>
<li><p>实际上，undefined 值是派生自null 值的，因此ECMA-262 规定对它们的相等性测试要返回true：<code>alert(null == undefined); //true</code>  </p>
</li>
</ul>
</li>
<li><p><strong>【Boolean类型的转换】</strong></p>
<p> 转换规则：</p>
<p> <img src="/js-type-and-object/pic31.PNG" alt="pic">  </p>
<p> <img src="/js-type-and-object/pic32.PNG" alt="pic">  </p>
</li>
<li><p><strong>【Number类型浮点数值计算会产生四舍五入的误差】</strong></p>
<ul>
<li><p>浮点数值的最高精度是17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加0.2的结果不是0.3，而是0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。因此，永远不要测试某个特定的浮点数值。</p>
</li>
<li><p>关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家；其他使用相同数值格式的语言也存在这个问题。</p>
</li>
</ul>
</li>
</ol>
<h2 id="chapter4">四、关于对象</h2>

<p><a href="#chapter5">（Js对象的分类）</a></p>
<p>constructor（构造函数）用来创建一个原生对象（native object），并返回该对象的实例。</p>
<p>在constructor里面的this指向这个【新创建的对象】，用new关键字调用constructor后，会自动返回这个新创建对象的实例（即：Object类型的数据（值））。</p>
<ul>
<li><p>【若这个“新创建的对象”是内置对象（build-in object）】：【内置对象（build-in object）的constructor】会创建内置对象，并返回内置对象的实例。（内置对象可以看作是“正规军”，是ECMAScript规范定义的对象，例如Array，Function等。）。内置对象（build-in object）的constructor对应有：Object()、Array()、Function()、Date()等，这些constructor官方已经写好，可以直接用new关键字调用，无需用户再写constructor，例如: <code>var arr = new Array()</code>、<code>var myDate = new Date()</code>。</p>
</li>
<li><p>【若这个“新创建的对象”是自定义对象（user-defined object）】：由于自定对象不是“正规军”，因此【自定义对象的constructor】要由用户自己来写。例如：</p>
</li>
</ul>
<pre>
// 用户自定义的constructor
// 当用new关键字来调用这个constructor时，会创建一个自定义对象
// constructor里面的this会指向这个正在被创建的自定义对象
// 通过【this.属性名】或【this.方法名】来创建对象实例的属性和方法
// 最后自动返回这个对象的实例
function myConstructor() {
    this.a = "Hello";
    this.b = function() {
        console.log(this.a);    
    }
}

var myObj = new myConstructor();  
// new关键字调用constructor后，constructor会返回一个Object类型的值（或者说是返回了一个对象的实例）
// 变量myObj存了一个Object类型的值（或者说变量myObj存了一个对象的实例）
</pre>

<h2 id="chapter5">附注：ECMAScript中对象的分类</h2>

<p><img src="/js-type-and-object/pic4.png" alt="pic"></p>
<p><strong>原生对象（native object）</strong>：遵循ECMAScript规范定义的对象。有2类，一类是内置对象（build-in object），一类是【自定义对象】（user-defined object）</p>
<p><strong>内置对象（build-in object）</strong>：遵循ECMAScript规范定义的对象，是ECMAScript官方定义的对象，看以看作是“正规军”对象。<br>ECMAScript的build-in object有：  </p>
<ol>
<li>The Global Object  </li>
<li>Object Objects  </li>
<li>Function Objects  </li>
<li>Array Objects  </li>
<li>String Objects  </li>
<li>Boolean Objects  </li>
<li>Number Objects  </li>
<li>The Math Object  </li>
<li>Date Objects  </li>
<li>RegExp (Regular Expression) Objects  </li>
<li>Error Objects  </li>
<li>The JSON Object</li>
</ol>
<p>（其中，Global对象和Math对象由被称为“单体内置对象”，这两个对象不需要用new关键字来调用，而是直接使用，例如<code>Math.floor(...)</code>）<br>（另外，Array对象、Function对象、RegExp对象、Boolean对象、String对象和Number对象等都是继承Object对象的）  </p>
<p><strong>自定义对象（user-defined object）</strong>：在运行中的Javascript代码创建的对象。</p>
<p><strong>宿主对象（host object）</strong>：在某个特殊的环境（场景）中，存在的一些特殊的对象，这些特殊的对象只有在这个特殊的环境（场景）中才存在，并遵循着这个特殊环境中的规范。例如宿主环境为浏览器时，会有window对象、navigator对象、location对象、 history对象、screen对象、document对象、XMLHttpRequest对象（所有不是native object 的都属于host object）</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
        <p class="copyright text-muted">
          © <a target="_blank" href="https://allenmind.cn/">Allenmind</a>
        </p>
        <p class="copyright text-muted" id="busuanzi_container_site_uv"> 
          本站访客数 <span id="busuanzi_value_site_uv"></span> 人次
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

